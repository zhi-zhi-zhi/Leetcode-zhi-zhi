## 方法一：摩尔投票 + 线段树
摩尔投票：[169. Majority Element](https://leetcode.com/problems/majority-element/)
线段树——核心思想，分段处理，区间查询通过子段合并

### 摩尔投票算法的结合性

摩尔投票中会存储两个值，这两个值具有***结合性***
- `x`：表示当前 majority number
- `count`：表示当前 majority number 的价值

如果下一个数 `y = x`，则 `count` 的值 +1，否则 -1.
当 `count` 变为 -1 时，将 `x` 替换为 `y`，并将 `count` 初始化为 1

### 结合性
对于一个给定的数组，我们可以将它分成任意两部分（不连续都可），分别使用摩尔投票算法得到 `(x_0, count_0)` 和 `(x_1, count_1)`。

此时整个数组使用投票算法得到的结果是：
- 若 `x_0 = x_1`，则结果为 `(x_0, count_0 + count_1)`
- 若 `x_0 != x_1`，则结果为 `count_0` 和 `count_1` 中较大值所对应的 `x`，以及 `count_0 - count_1`

### 正确性证明：

投票算法，本质上是在数组中不断找出两个不同的整数，然后消除。
当数组中消除完只剩下一种整数时，这个整数就是 `x`，它出现的次数就是 `count`。

倘若数组中存在 `majority nubmer`，则就是 `x`；
若不存在 `majority nubmer`，则剩下的 `x` 可以是任何值。

因此，首先将数组分为任意两部分，分别进行消除，得到 `count_0` 个 `x_0` 和 `count_1` 个 `x_1`。
再对它们进行消除，得到的就是整个数组投票算法的结果：

- 若存在 `majority number`——`x`，则根据鸽巢原理，这两部分中，至少有一个部分的 `majority number` 也是 `x`。
  - 即 `x_0` or `x_1` 其中至少有一个是 `x`，并且消除合并后留下的一定是 `x`
- 若不存在 `majority number`，那么这两组值都没有实际意义，无关紧要。

上述性质（结合性），可以推广至将数组拆分为任意多个部分（线段树）处理：
- 只要存在 `majority number`，则合并消除时最后一定留下的是 `x`，`count` 一定 > 0
- 若不存在 `majority number`，则合并消除最后留下的 `x` 可能是其中任何值。

针对上述情况，我们可以通过记录每个值出现的位置，再通过二分法快速判定最后留下的 `x` 出现的次数，从而验证 `x` 是否是 `majority number`

同理，也可根据二分法判定 `x` 在区间内出现的次数，同 `threshold` 对比从而解决本题。

Time Complexity: `O(n + q * log(n))` 。
预处理哈希表和线段树需要 `O(n)` 时间，每次查询耗时 `log(n)`，总共查询 `q` 次

Space complexity: `O(n)`。线段树和哈希表需要的空间。

